// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See http://js.arcgis.com/4.1/esri/copyright.txt for details.
//>>built
require({cache:{"url:esri/views/3d/webgl-engine/materials/HUDMaterial.xml":'\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8"?\x3e\r\n\r\n\x3csnippets\x3e\r\n\r\n\x3csnippet name\x3d"HUDMaterialCommonVariables"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float pixelRatio;\r\n\tuniform vec2 screenOffset;\r\n\tuniform vec2 anchorPos;\r\n\tuniform float polygonOffset;\r\n\tuniform float cameraGroundRelative;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec2 $uv0;\r\n\tattribute vec4 $color;\r\n  attribute vec2 $size;\r\n  attribute vec4 $auxpos1;\r\n\r\n\tvarying vec4 vcolor;\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n \tvarying vec4 vtc;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n\tuniform sampler2D framebufferTex;\r\n\tuniform vec3 markerColor;\r\n#endif\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"matchPixelOrigin"\x3e\x3c![CDATA[\r\n\tvec4 matchPixelOrigin(vec4 clipCoord, vec2 widthHeight) {\r\n\t\tvec2 xy \x3d vec2(.5) + .5 * clipCoord.xy / clipCoord.w;\r\n\t\tvec2 pixelSz \x3d vec2(1.0) / widthHeight;\r\n\t\tvec2 ij \x3d floor((xy + .5 * pixelSz) * widthHeight);\r\n\t\tvec2 result \x3d ((ij * pixelSz) * 2.0 - vec2(1.0)) * clipCoord.w;\r\n\t\treturn vec4(result.x, result.y, clipCoord.z, clipCoord.w);\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"calcPosMatchPixelCenter"\x3e\x3c![CDATA[\r\n\r\n\t\tvec3 posModel \x3d (model * vec4($position, 1.0)).xyz;\r\n\t\tvec3 posView \x3d (view * vec4(posModel, 1.0)).xyz;\r\n\r\n\t\tvec3 vnormal \x3d (modelNormal * vec4($normal, 1.0)).xyz;\r\n\r\n\t\t// groundRelative is 1 if both camera and symbol are on the same side of the ground, -1 otherwise\r\n\t\tfloat groundRelative \x3d cameraGroundRelative * sign(pointGroundDistance);\r\n\t\tif (groundRelative \x3d\x3d 0.0) groundRelative \x3d 1.0;\r\n\r\n\t\t// view angle dependent part of polygon offset emulation\r\n\t\t// we take the absolute value because the sign that is dropped is\r\n\t\t// instead introduced using the ground-relative position of the symbol and the camera\r\n\t\tfloat cosAlpha \x3d abs(dot(vnormal, normalize(camPos - posModel)));\r\n\t\tif (cosAlpha \x3e .01 \x26\x26 polygonOffset \x3e .0) {\r\n\t\t\tfloat tanAlpha \x3d sqrt(1.0 - cosAlpha * cosAlpha) / cosAlpha;\r\n\t\t\tfloat factor \x3d (1.0 - tanAlpha / viewport[2]);\r\n\t\t\t// same side of the terrain\r\n\t\t\tif (groundRelative \x3e 0.0) {\r\n\t\t\t\tposView *\x3d factor;\r\n\t\t\t}\r\n\t\t\t// opposite sides of the terrain\r\n\t\t\telse {\r\n\t\t\t\tposView /\x3d factor;\r\n\t\t\t}\r\n\t\t}\r\n\r\n    \tposView +\x3d centerOffset;\r\n\r\n\t\tvec4 posProj \x3d proj * vec4(posView, 1.0);\r\n\r\n\t\t// constant part of polygon offset emulation\r\n\t\tposProj.z -\x3d groundRelative * polygonOffset * posProj.w;\r\n\r\n\t\tposProjCenter \x3d matchPixelCenter(posProj, viewport.zw);\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUD"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\r\n\tvoid main(void) {\r\n\r\n\t    vec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n\r\n\t\tvec2 combinedSize \x3d $size * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tfloat dist \x3d distance(camPos, posModel);\r\n\t\t\tposProj.xy +\x3d ((uv01 - anchorPos) * 2.0 * combinedSize + screenOffset)/ viewport.zw * posProj.w;\r\n\t\t\tvtc.xy \x3d uv;\r\n\t\t\tvsize \x3d $size;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tgl_Position \x3d matchPixelOrigin(posProj, viewport.zw);\r\n\t\tvcolor \x3d $color / 255.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\r\n\t$matchPixelCenter\r\n\r\n\tvoid main(void) {\r\n\t    vec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n\t    vec2 combinedSize \x3d $size;\r\n\r\n\t    vec4 posProjCenter;\r\n\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tvec2 uv01 \x3d floor($uv0);\r\n\t\t\tvec2 uv \x3d $uv0 - uv01;\r\n\t\t\tposView.xy +\x3d (uv01 - anchorPos) * combinedSize * scale;\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tposProj \x3d proj * vec4(posView,1.0);\r\n\t\tposProj.xy +\x3d screenOffset / viewport.zw * posProj.w;\r\n\t\tgl_Position \x3d posProj;\r\n\t\tvcolor \x3d $color / 255.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\r\n\x3csnippet name\x3d"calcLabelDirections"\x3e\x3c![CDATA[\r\n\tvec2 uv01 \x3d floor($uv0);\r\n\tvec2 uv \x3d $uv0 - uv01;\r\n\r\n\tvec3 labelDir, labelDirOrtho;\r\n\r\n\tint isUp \x3d 0;\r\n\tvec2 vId \x3d (uv01 - vec2(.5, .5))*2.0;\r\n\r\n\tvec3 viewDirInNormalPlane \x3d normalize(camDir.xyz - dot(camDir.xyz, direction)*direction);\r\n\tfloat angleToNormal \x3d abs(dot(viewDirInNormalPlane,up));\r\n\tfloat angleToDirection \x3d abs(dot(camDir.xyz, direction));\r\n\tif (angleToDirection \x3c 0.985 \x26\x26 angleToNormal \x3c 0.500)\r\n\t{\r\n\t    if (angleToNormal \x3c 0.422) {\r\n\t\t    isUp \x3d 1;\r\n\t\t    labelDir \x3d direction;\r\n\t\t    labelDirOrtho \x3d up;\r\n\t\t    vId.y +\x3d 0.5;\r\n\t\t} else {\r\n\t\t    labelDir \x3d direction;\r\n            labelDirOrtho \x3d cross(viewDirInNormalPlane, direction);\r\n            vId.y +\x3d dot(labelDirOrtho, up)*0.5;\r\n\t\t}\r\n\t}\r\n\telse\r\n\t{\r\n\t\tlabelDir \x3d direction;\r\n\t\tlabelDirOrtho \x3d normalize(cross(up,direction));\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirection"\x3e\x3c![CDATA[\r\n  $HUDMaterialCommonVariables\r\n  uniform vec3 direction;\r\n\r\n  $matchPixelCenter\r\n\r\n\tvoid main(void) {\r\n\t    vec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n\t    vec2 combinedSize \x3d $size * pixelRatio;\r\n\r\n        vec4 posProjCenter;\r\n \t\t$calcPosMatchPixelCenter\r\n\r\n \t\tvec3 up \x3d vnormal;\r\n \t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n #ifdef OCCL_TEST\r\n \t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n #endif\r\n\r\n \t\t\t$calcLabelDirections\r\n\r\n\t\t    float scale;\r\n\t\t    if (proj[2][3] !\x3d 0.0)  // perspective projection\r\n \t\t\t    scale \x3d posProj.w*0.5/viewport[2];\r\n \t\t\telse                    // othographic projection\r\n \t\t\t    scale \x3d 2.0/proj[0][0]/viewport[2];\r\n\r\n \t\t\tposModel.xyz +\x3d labelDir * vId.x * combinedSize.x * scale ;\r\n \t\t\tposModel.xyz +\x3d labelDirOrtho * vId.y * combinedSize.y * scale;\r\n\r\n      // capability to flip upside down was lost when label texture atlases were implemented. this was the old code:\r\n \t\t\t//vec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n \t\t\t//vec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\t//if (posDirProj.x \x3c posProjUnmodified.x)\r\n \t\t\t//{\r\n \t\t\t//\tif (isUp\x3d\x3d1)\r\n \t\t\t//\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t//\telse\r\n \t\t\t//\t\tuv \x3d texScale-uv;\r\n \t\t\t//}\r\n \t\t\tvtc.xy \x3d uv;\r\n #ifdef OCCL_TEST\r\n \t\t} else {\r\n \t\t\tvtc \x3d vec2(.0);\r\n \t\t}\r\n #endif\r\n\r\n #ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n \t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n \t\tgl_Position \x3d pos4;\r\n \t\tvcolor \x3d $color / 255.0;\r\n \t}\r\n ]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderHUDDirectionWorldScale"\x3e\x3c![CDATA[\r\n    $HUDMaterialCommonVariables\r\n\r\n\tuniform vec2 minMaxWorldSizeFactor;\r\n\tuniform vec3 direction;\r\n\r\n\t$matchPixelCenter\r\n\t$matchPixelOrigin\r\n\r\n\tvoid main(void) {\r\n\t    vec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n\t    vec2 combinedSize \x3d $size;\r\n\r\n        vec4 posProjCenter;\r\n\t\t$calcPosMatchPixelCenter\r\n\r\n\t\tvec3 up \x3d vnormal;\r\n\t\tvec3 camDir \x3d normalize(vec3(view[0][2],view[1][2],view[2][2]));\r\n\r\n#ifdef OCCL_TEST\r\n\t\tif (texture2D(framebufferTex, .5 + .5 * posProjCenter.xy / posProjCenter.w).rgb \x3d\x3d markerColor) {\r\n#endif\r\n\r\n\t\t\t$calcLabelDirections\r\n\r\n\t\t\tfloat scale \x3d 1.0;\r\n\t\t\tvec2 minMaxWorldSize \x3d minMaxWorldSizeFactor;\r\n\t\t\tif (proj[2][3] !\x3d 0.0)  // perspective projection\r\n\t\t\t\tminMaxWorldSize \x3d distance(camPos, position)*minMaxWorldSizeFactor;\r\n\t\t\tif (minMaxWorldSize.x \x3e combinedSize.y)\r\n\t\t\t\tscale \x3d 0.5 * minMaxWorldSize.x / combinedSize.y;\r\n\t\t\telse if (minMaxWorldSize.y \x3e 0.0)\r\n\t\t\t\tscale \x3d 0.5 * min(1.0, minMaxWorldSize.y / combinedSize.y);\r\n\r\n\t\t\tposModel.xyz +\x3d labelDir*vId.x*combinedSize.x*scale;\r\n\t\t\tposModel.xyz +\x3d labelDirOrtho*vId.y*combinedSize.y*scale;\r\n\r\n      // capability to flip upside down was lost when label texture atlases were implemented. this was the old code:\r\n\t\t\t//vec4 posDirProj \x3d proj*view*model * vec4($position+direction, 1.0);\r\n\t\t\t//vec4 posProjUnmodified \x3d proj*view*model * vec4($position, 1.0);\r\n \t\t\t//if (posDirProj.x\x3cposProjUnmodified.x)\r\n \t\t\t//{\r\n \t\t\t//\tif (isUp\x3d\x3d1)\r\n \t\t\t//\t\tuv.x \x3d texScale.x-uv.x;\r\n \t\t\t//\telse\r\n \t\t\t//\t\tuv \x3d texScale-uv;\r\n \t\t\t//}\r\n \t\t\t//uv.y +\x3d (1.0 - texScale.y);\r\n\t\t\tvtc.xy \x3d uv;\r\n#ifdef OCCL_TEST\r\n\t\t} else {\r\n\t\t\tvtc \x3d vec2(.0);\r\n\t\t}\r\n#endif\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvtc.zw \x3d .5 + .5 * posProjCenter.xy / posProjCenter.w;\r\n#endif\r\n\t\tvec4 pos4 \x3d proj * view * vec4(posModel,1.0);\r\n\t\tgl_Position \x3d pos4;\r\n\t\tvcolor \x3d $color / 255.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDBase"\x3e\x3c![CDATA[\r\n\tprecision mediump float;\r\n\r\n\t#extension GL_OES_standard_derivatives : require\r\n\r\n\tuniform sampler2D tex;\r\n\tuniform vec4 overrideColor;\r\n\tuniform vec4 outlineColor;\r\n\tuniform float outlineSize;\r\n\r\n\tvarying vec4 vcolor;\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n\tvarying vec4 vtc;\r\n\tuniform vec3 markerColor;\r\n\tuniform sampler2D framebufferTex;\r\n#else\r\n\tvarying vec2 vtc;\r\n\tvarying vec2 vsize;\r\n#endif\r\n\r\n\tvoid main() {\r\n\r\n#ifdef OCCL_PIXELSHADER\r\n   \t\tif (texture2D(framebufferTex, vtc.zw).rgb !\x3d markerColor)\r\n   \t\t\tdiscard;\r\n#endif\r\n\r\n#ifdef SIGNED_DISTANCE_FIELD\r\n\t\tvec4 color \x3d vec4(0.0, 0.0, 0.0, 0.0);\r\n\t\tvec4 fillPixelColor \x3d overrideColor * vcolor;\r\n\r\n\t\t// Distance in [-0.5, 0.5]\r\n\t\tfloat d \x3d dot(texture2D(tex, vtc), vec4(1.0/16777216.0, 1.0/65535.0, 1.0/256.0, 1.0)) - 0.5;\r\n\t\t// Distance in output units\r\n\t\tfloat dist \x3d d * vsize.x;\r\n\r\n\t\tfillPixelColor.a *\x3d clamp(0.5 - dist, 0.0, 1.0);\r\n\r\n\t\tif (outlineSize \x3e 0.25) {\r\n\t\t\tvec4 outlinePixelColor \x3d outlineColor;\r\n\t\t\tfloat clampedOutlineSize \x3d min(outlineSize, 0.5*vsize.x);\r\n\t\t\toutlinePixelColor.a *\x3d clamp(0.5 - (abs(dist) - 0.5*clampedOutlineSize), 0.0, 1.0);\r\n\r\n\t\t\t// perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Description)\r\n\t\t\tfloat compositeAlpha \x3d outlinePixelColor.a + fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tvec3 compositeColor \x3d vec3(outlinePixelColor) * outlinePixelColor.a +\r\n\t\t\t\tvec3(fillPixelColor) * fillPixelColor.a * (1.0 - outlinePixelColor.a);\r\n\t\t\tcompositeColor /\x3d compositeAlpha;\r\n\r\n\t\t\tgl_FragColor \x3d vec4(compositeColor, compositeAlpha);\r\n\t\t}\r\n\t\telse {\r\n\t\t\tgl_FragColor \x3d fillPixelColor;\r\n\t\t}\r\n\r\n\t\t// visualize SDF:\r\n\t\t// gl_FragColor \x3d vec4(clamp(-dist/vsize.x*2.0, 0.0, 1.0), clamp(dist/vsize.x*2.0, 0.0, 1.0), 0.0, 1.0);\r\n#else\r\n\t\tgl_FragColor \x3d texture2D(tex, vtc, -0.5) * overrideColor * vcolor;\r\n#endif\r\n\r\n\t\tif (gl_FragColor.a \x3c 0.1) {\r\n\t\t\tdiscard;\r\n\t\t}\r\n\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUD"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBase\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3csnippet name\x3d"fragmentShaderHUDHighlight"\x3e\x3c![CDATA[\r\n$fragmentShaderHUDBase\r\n  gl_FragColor \x3d vec4(1.0, 1.0, 1.0, 1.0);\r\n}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\r\n\x3csnippet name\x3d"vertexShaderOcclusionTestPixel"\x3e\x3c![CDATA[\r\n\tuniform mat4 proj;\r\n\tuniform mat4 view;\r\n\tuniform mat4 model;\r\n\tuniform mat4 modelNormal;\r\n\tuniform vec4 viewport;\r\n\tuniform vec3 camPos;\r\n\tuniform float polygonOffset;\r\n\tuniform float cameraGroundRelative;\r\n\r\n\tattribute vec3 $position;\r\n\tattribute vec3 $normal;\r\n\tattribute vec4 $auxpos1;\r\n\r\n\t$matchPixelCenter\r\n\r\n\tvoid main(void) {\r\n\t    vec3 centerOffset \x3d $auxpos1.xyz;\r\n\t\tfloat pointGroundDistance \x3d $auxpos1.w;\r\n\r\n\t    vec4 posProjCenter;\r\n\t    if (dot($position, $position) \x3e 0.0) {\r\n\t\t    $calcPosMatchPixelCenter\r\n\t\t} else {\r\n\t\t    posProjCenter \x3d vec4(1e038, 1e038, 1e038, 1.0);\r\n\t\t}\r\n\r\n\t\tgl_Position \x3d posProjCenter;\r\n\t\tgl_PointSize \x3d 1.0;\r\n\t}\r\n]]\x3e\x3c/snippet\x3e\r\n\r\n\x3c/snippets\x3e\r\n'}});
define("dojo/_base/lang dojo/text!./HUDMaterial.xml ./internal/MaterialUtil ../lib/ShaderVariations ../lib/Util ../lib/gl-matrix ../lib/RenderSlot ../../../webgl/Program ../lib/DefaultVertexAttributeLocations ../../../webgl/Util".split(" "),function(G,J,r,H,A,D,E,K,L,y){var I=D.vec2d,x=D.vec3d,M=D.mat4d,C=A.assert,g=A.VertexAttrConstants,F={"bottom-left":[0,0],bottom:[0.5,0],"bottom-right":[1,0],left:[0,0.5],center:[0.5,0.5],right:[1,0.5],"top-left":[0,1],top:[0.5,1],"top-right":[1,1]},B=[253/255,
231/255,229/255];A=function(d,z){r.basicMaterialConstructor(this,z);d=d||null;d.texCoordScale=d.texCoordScale||[1,1];d.occlusionTest=void 0!==d.occlusionTest?d.occlusionTest:!0;d.color=d.color||[1,1,1,1];d.screenMinMaxSize=d.screenMinMaxSize||[0,1E5];d.outlineColor=d.outlineColor||[1,1,1,1];d.outlineSize=d.outlineSize||0;d.textureIsSignedDistanceField=d.textureIsSignedDistanceField?1:0;d.distanceFieldBoundingBox=d.distanceFieldBoundingBox||[0.25,0.25,0.75,0.75];d.screenOffset?d.screenOffset.forEach(function(b,
c){d.screenOffset[c]=2*b}):d.screenOffset=[0,0];"string"===typeof d.anchorPos?(C(F[d.anchorPos],"HUDMaterial: invalid anchorPos specified"),d.anchorPos=F[d.anchorPos]):d.anchorPos||(d.anchorPos=F.center);null==d.shaderPolygonOffset&&(d.shaderPolygonOffset=1E-5);var u=[{name:"position",count:3,type:5126,offset:0,stride:60,normalized:!1},{name:"normal",count:3,type:5126,offset:12,stride:60,normalized:!1},{name:"uv0",count:2,type:5126,offset:24,stride:60,normalized:!1},{name:"color",count:4,type:5121,
offset:32,stride:60,normalized:!1},{name:"size",count:2,type:5126,offset:36,stride:60,normalized:!1},{name:"auxpos1",count:4,type:5126,offset:44,stride:60,normalized:!1}],s=y.getStride(u),c=s/4;this.dispose=function(){};this.getParameterValues=function(){var b={color:d.color,texCoordScale:d.texCoordScale,polygonOffset:d.polygonOffset,anchorPos:d.anchorPos,screenOffset:d.screenOffset,screenMinMaxSize:d.screenMinMaxSize,shaderPolygonOffset:d.shaderPolygonOffset,textureIsSignedDistanceField:d.textureIsSignedDistanceField,
outlineColor:d.outlineColor,outlineSize:d.outlineSize,distanceFieldBoundingBox:d.distanceFieldBoundingBox};d.textureId&&(b.textureId=d.textureId);d.direction&&(b.direction=d.direction);return b};this.setParameterValues=function(b){for(var c in b)"textureId"===c&&C(d.textureId,"Can only change texture of material that already has a texture"),"direction"===c&&C(d.direction,"Can only change direction of HUDMaterial which was initialized with a direction"),d[c]=b[c];this.notifyDirty("matChanged")};this.getParams=
function(){return d};this.getOutputAmount=function(b){return 6*b*c};this.getVertexBufferLayout=function(){return u};this.fillInterleaved=function(b,h,l,f,e,m){var q=4*m;f=r.fill;for(var n=b.faces.indices[g.POSITION],t=b.vertexAttr[g.POSITION].data,a=m+y.findAttribute(u,g.POSITION).offset/4,p=0;p<n.length;++p){var k=3*n[p];f(t,k,e,a,h,3);a+=c;f(t,k,e,a,h,3);a+=c;f(t,k,e,a,h,3);a+=c;f(t,k,e,a,h,3);a+=c;f(t,k,e,a,h,3);a+=c;f(t,k,e,a,h,3);a+=c}h=b.faces.indices[g.NORMAL];t=b.vertexAttr[g.NORMAL].data;
a=m+y.findAttribute(u,g.NORMAL).offset/4;for(p=0;p<h.length;++p)k=3*h[p],f(t,k,e,a,l,3),a+=c,f(t,k,e,a,l,3),a+=c,f(t,k,e,a,l,3),a+=c,f(t,k,e,a,l,3),a+=c,f(t,k,e,a,l,3),a+=c,f(t,k,e,a,l,3),a+=c;a=m+y.findAttribute(u,g.UV0).offset/4;p=b.vertexAttr[g.UV0].data;null==p||3>=p.length?(l=k=0,h=d.texCoordScale[0],t=d.texCoordScale[1]):(k=b.vertexAttr[g.UV0].data[0],l=b.vertexAttr[g.UV0].data[1],h=b.vertexAttr[g.UV0].data[2],t=b.vertexAttr[g.UV0].data[3]);h=Math.min(1.99999,h+1);t=Math.min(1.99999,t+1);for(p=
0;p<n.length;++p)e[a]=k,e[a+1]=l,a+=c,e[a]=h,e[a+1]=l,a+=c,e[a]=h,e[a+1]=t,a+=c,e[a]=h,e[a+1]=t,a+=c,e[a]=k,e[a+1]=t,a+=c,e[a]=k,e[a+1]=l,a+=c;n=b.faces.indices[g.COLOR];l=b.vertexAttr[g.COLOR].data;a=q+y.findAttribute(u,g.COLOR).offset;q=new Uint8Array(e.buffer);for(p=0;p<n.length;++p)k=4*n[p],f(l,k,q,a,null,4),a+=s,f(l,k,q,a,null,4),a+=s,f(l,k,q,a,null,4),a+=s,f(l,k,q,a,null,4),a+=s,f(l,k,q,a,null,4),a+=s,f(l,k,q,a,null,4),a+=s;q=b.faces.indices[g.SIZE];n=b.vertexAttr[g.SIZE].data;a=m+y.findAttribute(u,
g.SIZE).offset/4;for(p=0;p<q.length;++p)k=n[2*q[p]],l=n[2*q[p]+1],e[a]=k,e[a+1]=l,a+=c,e[a]=k,e[a+1]=l,a+=c,e[a]=k,e[a+1]=l,a+=c,e[a]=k,e[a+1]=l,a+=c,e[a]=k,e[a+1]=l,a+=c,e[a]=k,e[a+1]=l,a+=c;if(null!=b.faces.indices[g.AUXPOS1]&&null!=b.vertexAttr[g.AUXPOS1]){q=b.faces.indices[g.AUXPOS1];b=b.vertexAttr[g.AUXPOS1].data;a=m+y.findAttribute(u,"auxpos1").offset/4;for(p=0;p<q.length;++p)k=4*q[p],f(b,k,e,a,null,4),a+=c,f(b,k,e,a,null,4),a+=c,f(b,k,e,a,null,4),a+=c,f(b,k,e,a,null,4),a+=c,f(b,k,e,a,null,
4),a+=c,f(b,k,e,a,null,4),a+=c}};var w=x.create(),m=x.create(),b=[0,0];this.intersect=function(c,h,l,f,e,u,q,n,t,a,p,k){if(k){h=c.getData().getVertexAttr()[g.POSITION];c=c.getData().getVertexAttr()[g.SIZE];C(3<=h.size);for(q=0;q<h.data.length/h.size;q++)if(n=q*h.size,x.set3(h.data[n],h.data[n+1],h.data[n+2],w),M.multiplyVec3(l,w,w),n=q*c.size,b[0]=c.data[n],b[1]=c.data[n+1],t.projectPoint(w,m),-1<m[0]){k=d.anchorPos;n=m[0]-1-(0<k[0]?b[0]*k[0]:0);a=n+b[0];k=m[1]-1-(0<k[1]?b[1]*k[1]:0);var s=k+b[1];
if(d.textureIsSignedDistanceField){var z=d.distanceFieldBoundingBox,r=d.outlineSize/2;n+=b[0]*z[0]-r;a-=b[0]*(1-z[2])-r;k+=b[1]*z[1]-r;s-=b[1]*(1-z[3])-r}f[0]>n&&(f[0]<a&&f[1]>k&&f[1]<s)&&(n=x.subtract(e,w,x.create()),a=x.length(n),x.scale(n,1/a),a=0.98*a/x.dist(e,u),p(a,n,-1,1,!0))}}};this.getGLMaterials=function(){return{color:N,depthShadowMap:void 0,normal:void 0,depth:void 0,highlight:O}};this.getAllTextureIds=function(){return[d.textureId]};this._textureDirty=!1;this.setTextureDirty=function(){this._textureDirty=
!0}};var N=function(d,g,u){function s(){return g.shaderVariators.HUDMaterial.getProgram([!!b.direction,!!b.worldScale,b.occlusionTest,b.textureIsSignedDistanceField])}r.basicGLMaterialConstructor(this,d);var c=E.OCCLUSION_PIXELS,w=E.OVERLAY,m=0,b=G.clone(d.getParams()),v=g.get("hudOcclusionTestPixel"),h=s();r.singleTextureGLMaterialConstructor(this,u,b);this.beginSlot=function(d){m=d;return b.occlusionTest?d===c||d===w:d===w};this.getProgram=function(){return m===c&&b.occlusionTest?v:h};this.getAllPrograms=
function(){return[v,h]};this.updateParameters=function(){var c=d.getParams();b.color=c.color;b.texCoordScale=c.texCoordScale;b.polygonOffset=c.polygonOffset;b.anchorPos=c.anchorPos;b.screenOffset=c.screenOffset;b.screenMinMaxSize=c.screenMinMaxSize;b.direction=c.direction;b.shaderPolygonOffset=c.shaderPolygonOffset;b.textureIsSignedDistanceField=c.textureIsSignedDistanceField;b.outlineColor=c.outlineColor;b.outlineSize=c.outlineSize;this.updateTexture(c.textureId);h=s()};this.bind=function(l,f){d._textureDirty&&
(this.renderTexture(l),d._textureDirty=!1);var e=l.gl,g=f.cameraAboveGround?1:-1;if(m===c&&b.occlusionTest)l.bindProgram(v),v.setUniform1f("cameraGroundRelative",g),v.setUniform1f("polygonOffset",b.shaderPolygonOffset),v.setUniform4fv("viewport",f.viewport),v.setUniform4f("color",B[0],B[1],B[2],1),l.setDepthFunction(e.LEQUAL);else{l.bindProgram(h);h.setUniform1f("cameraGroundRelative",g);this.bindTexture(l,h);h.setUniform1i("framebufferTex",1);l.bindTexture(f.framebufferTex,1);l.setActiveTexture(0);
h.setUniform3fv("markerColor",B);h.setUniform4fv("viewport",f.viewport);h.setUniform4fv("overrideColor",b.color);h.setUniform1f("pixelRatio",f.pixelRatio);h.setUniform1f("polygonOffset",b.shaderPolygonOffset);b.textureIsSignedDistanceField&&(h.setUniform4fv("outlineColor",b.outlineColor),h.setUniform1f("outlineSize",b.outlineSize));if(b.worldScale){var e=[-1,-1],g=b.screenMinMaxSize,q=f.proj,n=f.viewport[2]/f.pixelRatio;g&&(0!==q[11]?(q=2*Math.atan(1/q[0]),n=2*(Math.tan(q/2)/n),e[0]=g[0]*n,e[1]=g[1]*
n):I.scale(g,2/(q[0]*n),e));h.setUniform2fv("minMaxWorldSizeFactor",e)}b.direction&&h.setUniform3fv("direction",b.direction);h.setUniform2fv("texScale",b.texCoordScale);h.setUniform2fv("screenOffset",b.screenOffset);h.setUniform2fv("anchorPos",b.anchorPos);b.polygonOffset&&(l.setPolygonOffsetFillEnabled(!0),l.setPolygonOffset(0,-4));l.setBlendingEnabled(!0)}};this.release=function(d){var f=d.gl;m===c&&b.occlusionTest?d.setDepthFunction(f.LESS):(d.setPolygonOffsetFillEnabled(!1),d.setBlendingEnabled(!1))};
this.bindView=function(d,f){var e=f.origin;m===c&&b.occlusionTest?(r.bindView(e,f.view,v),r.bindCamPos(e,f.viewInvTransp,v)):(r.bindView(e,f.view,h),r.bindCamPos(e,f.viewInvTransp,h))};this.bindInstance=function(d,f){m===c&&b.occlusionTest?(v.setUniformMatrix4fv("model",f.transformation),v.setUniformMatrix4fv("modelNormal",f.transformationNormal)):h.setUniformMatrix4fv("model",f.transformation)};this.getDrawMode=function(d){d=d.gl;return m===c&&b.occlusionTest?d.POINTS:d.TRIANGLES}},O=function(d,
g,u){function s(){return g.shaderVariators.HUDMaterialHighlight.getProgram([!!c.direction,!!c.worldScale,c.occlusionTest,c.textureIsSignedDistanceField])}r.basicGLMaterialConstructor(this,d);var c=G.clone(d.getParams()),w=g.get("hudOcclusionTestPixel"),m=s();r.singleTextureGLMaterialConstructor(this,u,c);this.beginSlot=function(b){return b===E.OVERLAY};this.getProgram=function(){return m};this.getAllPrograms=function(){return[w,m]};this.updateParameters=function(){var b=d.getParams();c.color=b.color;
c.texCoordScale=b.texCoordScale;c.polygonOffset=b.polygonOffset;c.anchorPos=b.anchorPos;c.screenOffset=b.screenOffset;c.screenMinMaxSize=b.screenMinMaxSize;c.direction=b.direction;c.shaderPolygonOffset=b.shaderPolygonOffset;c.textureIsSignedDistanceField=b.textureIsSignedDistanceField;c.outlineColor=b.outlineColor;c.outlineSize=b.outlineSize;this.updateTexture(b.textureId);m=s()};this.bind=function(b,g){d._textureDirty&&(this.renderTexture(b),d._textureDirty=!1);b.bindProgram(m);this.bindTexture(b,
m);m.setUniform1i("framebufferTex",1);b.bindTexture(g.framebufferTex,1);b.setActiveTexture(0);m.setUniform3fv("markerColor",B);m.setUniform4fv("viewport",g.viewport);m.setUniform4fv("overrideColor",c.color);m.setUniform1f("pixelRatio",g.pixelRatio);m.setUniform1f("polygonOffset",c.shaderPolygonOffset);c.textureIsSignedDistanceField&&(m.setUniform4fv("outlineColor",c.outlineColor),m.setUniform1f("outlineSize",c.outlineSize));if(c.worldScale){var h=[-1,-1],l=c.screenMinMaxSize,f=g.proj,e=g.viewport[2]/
g.pixelRatio;l&&(0!==f[11]?(f=2*Math.atan(1/f[0]),e=2*(Math.tan(f/2)/e),h[0]=l[0]*e,h[1]=l[1]*e):I.scale(l,2/(f[0]*e),h));m.setUniform2fv("minMaxWorldSizeFactor",h)}c.direction&&m.setUniform3fv("direction",c.direction);m.setUniform2fv("texScale",c.texCoordScale);m.setUniform2fv("screenOffset",c.screenOffset);m.setUniform2fv("anchorPos",c.anchorPos);c.polygonOffset&&(b.setPolygonOffsetFillEnabled(!0),b.setPolygonOffset(0,-4));b.setBlendingEnabled(!0)};this.release=function(b){b.setPolygonOffsetFillEnabled(!1);
b.setBlendingEnabled(!1)};this.bindView=function(b,c){var d=c.origin;r.bindView(d,c.view,m);r.bindCamPos(d,c.viewInvTransp,m)};this.bindInstance=function(b,c){m.setUniformMatrix4fv("model",c.transformation)};this.getDrawMode=function(b){return b.gl.TRIANGLES}};A.loadShaders=function(d,g,u,s){d._parse(J);var c=0<s.parameters.maxVertexTextureImageUnits,r=new H("hud",["vertexShaderHUD","fragmentShaderHUD"],null,u,g,d,s);r.addBinaryShaderSnippetSuffix("Direction","Direction",[!0,!1]);r.addBinaryShaderSnippetSuffix("WorldScale",
"WorldScale",[!0,!1]);r.addDefine("OcclTest",c?"OCCL_TEST":"OCCL_PIXELSHADER");r.addDefine("SDF","SIGNED_DISTANCE_FIELD");u.shaderVariators.HUDMaterial=r;g=new H("hudHighlight",["vertexShaderHUD","fragmentShaderHUDHighlight"],null,u,g,d,s);g.addBinaryShaderSnippetSuffix("Direction","Direction",[!0,!1]);g.addBinaryShaderSnippetSuffix("WorldScale","WorldScale",[!0,!1]);g.addDefine("OcclTest",c?"OCCL_TEST":"OCCL_PIXELSHADER");g.addDefine("SDF","SIGNED_DISTANCE_FIELD");u.shaderVariators.HUDMaterialHighlight=
g;d=new K(s,d.vertexShaderOcclusionTestPixel,d.fragmentShaderSimple,L.Default3D);u.add("hudOcclusionTestPixel",d)};return A});